#!/usr/bin/env bash
#===============================================================================
# protocol-zero.sh — AI Attribution Enforcement Scanner
#===============================================================================
#
# Automated enforcement of Protocol Zero: scans codebase and commit metadata
# for forbidden AI attribution markers as defined in CLAUDE.md governance.
#
# AUTHORITY: This script enforces policies defined in CLAUDE.md Section 1.
#
# EXIT CODES:
#   0   Clean — no violations detected
#   1   Violation — attribution markers found
#   2   Usage error — invalid arguments or missing dependencies
#   3   Environment error — required tools unavailable
#
# USAGE:
#   ./tools/protocol-zero.sh                         # Full codebase scan
#   ./tools/protocol-zero.sh --dir <path>            # Scan specific directory
#   ./tools/protocol-zero.sh --commit-msg "message"  # Validate commit message
#   ./tools/protocol-zero.sh --commit-msg-file <path># Validate from file
#   ./tools/protocol-zero.sh --dry-run               # Preview without scanning
#   ./tools/protocol-zero.sh --verbose               # Extended diagnostics
#   ./tools/protocol-zero.sh --help                  # Display usage
#
# INTEGRATION:
#   Pre-commit hook:  ./tools/protocol-zero.sh --commit-msg-file "$1"
#   CI pipeline:      ./tools/protocol-zero.sh --dir .
#
#===============================================================================

set -euo pipefail

#===============================================================================
# CONFIGURATION: Script metadata
#===============================================================================

readonly SCRIPT_NAME="protocol-zero"
readonly SCRIPT_VERSION="1.0.0"
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

#===============================================================================
# CONFIGURATION: ANSI color codes (POSIX-compatible)
#===============================================================================

if [[ -t 1 ]] && [[ "${NO_COLOR:-}" != "1" ]]; then
    readonly RED='\033[0;31m'
    readonly GREEN='\033[0;32m'
    readonly YELLOW='\033[0;33m'
    readonly BLUE='\033[0;34m'
    readonly BOLD='\033[1m'
    readonly DIM='\033[2m'
    readonly NC='\033[0m'
else
    readonly RED=''
    readonly GREEN=''
    readonly YELLOW=''
    readonly BLUE=''
    readonly BOLD=''
    readonly DIM=''
    readonly NC=''
fi

#===============================================================================
# CONFIGURATION: Prohibited patterns
#===============================================================================
# These patterns indicate AI attribution violating Protocol Zero governance.
# Pattern matching is case-insensitive.
# WARNING: Modifying this list requires architectural review.
#===============================================================================

readonly -a PROHIBITED_PATTERNS=(
    # === Direct AI Attribution (CLAUDE.md §1.1) ===
    "generated by claude"
    "generated by ai"
    "generated by copilot"
    "generated by gpt"
    "generated by chatgpt"
    "generated by llm"
    "generated by gemini"
    "generated by anthropic"
    "generated by openai"

    # === AI Assistance Indicators ===
    "ai.assisted"
    "ai-assisted"
    "ai assisted"
    "ai generated"
    "ai-generated"
    "created with ai"
    "created by ai"
    "written by ai"
    "written by claude"
    "written by gpt"
    "written by copilot"
    "llm-optimized"

    # === Git Co-Author Attribution ===
    "co-authored-by:.*claude"
    "co-authored-by:.*copilot"
    "co-authored-by:.*\\bai\\b"
    "co-authored-by:.*anthropic"
    "co-authored-by:.*openai"
    "co-authored-by:.*gemini"
    "co-authored-by:.*noreply@anthropic"

    # === Conversational Filler (CLAUDE.md §1.1) ===
    "i hope this helps"
    "as requested"
    "here is the code"
    "as an ai"
    "as a language model"
    "i'm an ai"
    "i am an ai"
    "based on the design doc"
    "i have updated"

    # === Apologetic Preambles ===
    "let me help you"
    "i'll help you"
    "i can help"
    "happy to help"
    "certainly!"
    "of course!"
    "absolutely!"
)

#===============================================================================
# CONFIGURATION: Directory exclusions
#===============================================================================
# Directories excluded from scanning. These contain generated artifacts,
# dependencies, or binary content where attribution markers are irrelevant.
#===============================================================================

readonly -a EXCLUDE_DIRS=(
    # === Version Control ===
    ".git"

    # === dbt Artifacts (per dbt-labs/dbt-starter-project) ===
    "target"
    "dbt_packages"
    "dbt_modules"
    "logs"

    # === Python Environments & Caches ===
    ".venv"
    "venv"
    "env"
    ".env"
    "__pycache__"
    ".mypy_cache"
    ".pytest_cache"
    ".ruff_cache"
    ".tox"
    "*.egg-info"
    "dist"
    "build"

    # === Node.js (if frontend tooling exists) ===
    "node_modules"
    ".pnpm"
    ".next"
    ".turbo"

    # === Data & Artifacts (project-specific) ===
    "data"

    # === IDE & Editor ===
    ".idea"
    ".vscode"

    # === Jupyter ===
    ".ipynb_checkpoints"

    # === Elementary (dbt observability) ===
    "edr_target"
)

#===============================================================================
# CONFIGURATION: Path pattern exclusions
#===============================================================================
# Partial path patterns to exclude. These are governance or documentation
# paths that legitimately reference the policy being enforced.
#===============================================================================

readonly -a EXCLUDE_PATH_PATTERNS=(
    ".github/"
    "docs/design"
    "docs/epics"
    "setup/"
)

#===============================================================================
# CONFIGURATION: File exclusions
#===============================================================================
# Specific filenames excluded from scanning. These are governance files
# that necessarily contain the prohibited patterns as documentation.
#===============================================================================

readonly -a EXCLUDE_FILES=(
    "CLAUDE.md"
    "protocol-zero.sh"
    "DESIGN-DOC.md"
    "design_doc.md"
    ".gitignore"
    ".dbtignore"
    "profiles.yml.example"
    "CHANGELOG.md"
)

#===============================================================================
# CONFIGURATION: Binary extensions
#===============================================================================
# File extensions known to be binary or non-textual. Scanning these is
# wasteful and may produce false positives.
#===============================================================================

readonly -a BINARY_EXTENSIONS=(
    # === Images ===
    "png" "jpg" "jpeg" "gif" "ico" "svg" "webp" "bmp" "tiff"
    # === Fonts ===
    "woff" "woff2" "ttf" "eot" "otf"
    # === Documents ===
    "pdf" "doc" "docx" "xls" "xlsx" "ppt" "pptx"
    # === Archives ===
    "zip" "tar" "gz" "bz2" "7z" "rar" "xz"
    # === Media ===
    "mp3" "mp4" "wav" "avi" "mov" "mkv" "flac"
    # === Lock Files ===
    "lock" "lockb"
    # === Data Files ===
    "parquet" "avro" "orc" "feather"
    # === Compiled ===
    "pyc" "pyo" "so" "dylib" "dll" "exe" "o" "a"
)

#===============================================================================
# STATE: Runtime variables
#===============================================================================

VIOLATIONS_FOUND=0
declare -a VIOLATION_DETAILS=()
DRY_RUN=0
VERBOSE=0

#===============================================================================
# FUNCTION: cleanup
# Handles graceful cleanup on script exit. Invoked via trap.
#===============================================================================

cleanup() {
    local exit_code=$?
    # Placeholder for future resource cleanup (temp files, locks, etc.)
    # Currently no persistent resources require cleanup.
    exit "${exit_code}"
}

#===============================================================================
# FUNCTION: trap_handler
# Handles signal interrupts with informative messaging.
#===============================================================================

trap_handler() {
    local signal="$1"
    log_warning "Received ${signal}, terminating gracefully..."
    exit 130
}

#===============================================================================
# TRAP REGISTRATION
# Ensures cleanup runs on all exit paths and handles interrupts gracefully.
#===============================================================================

trap cleanup EXIT
trap 'trap_handler SIGINT' INT
trap 'trap_handler SIGTERM' TERM

#===============================================================================
# FUNCTION: log_info
# Outputs informational messages to stdout.
#===============================================================================

log_info() {
    printf "[INFO] %s\n" "$1"
}

#===============================================================================
# FUNCTION: log_verbose
# Outputs verbose diagnostic messages when --verbose is enabled.
#===============================================================================

log_verbose() {
    if [[ "${VERBOSE}" -eq 1 ]]; then
        printf "${DIM}[DEBUG] %s${NC}\n" "$1"
    fi
}

#===============================================================================
# FUNCTION: log_warning
# Outputs warning messages to stderr with yellow highlighting.
#===============================================================================

log_warning() {
    printf "${YELLOW}[WARN]${NC} %s\n" "$1" >&2
}

#===============================================================================
# FUNCTION: log_error
# Outputs error messages to stderr with red highlighting.
#===============================================================================

log_error() {
    printf "${RED}[ERROR]${NC} %s\n" "$1" >&2
}

#===============================================================================
# FUNCTION: log_pass
# Outputs success messages with green highlighting.
#===============================================================================

log_pass() {
    printf "${GREEN}${BOLD}[PASS]${NC} ${GREEN}%s${NC}\n" "$1"
}

#===============================================================================
# FUNCTION: log_fail
# Outputs failure messages with red highlighting.
#===============================================================================

log_fail() {
    printf "${RED}${BOLD}[FAIL]${NC} ${RED}%s${NC}\n" "$1"
}

#===============================================================================
# FUNCTION: print_header
# Outputs a formatted section header.
#===============================================================================

print_header() {
    local title="$1"
    printf "\n%s\n" "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    printf "%s\n" "${title}"
    printf "%s\n\n" "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
}

#===============================================================================
# FUNCTION: print_violation
# Formats and outputs a single violation record.
#===============================================================================

print_violation() {
    local file="$1"
    local line_num="$2"
    local content="$3"
    local pattern="$4"

    printf "  ${RED}├─${NC} ${BOLD}%s${NC}:%s\n" "${file}" "${line_num}"
    printf "  │  Pattern: ${YELLOW}%s${NC}\n" "${pattern}"
    printf "  │  Content: %.80s\n" "${content}"
}

#===============================================================================
# FUNCTION: check_dependencies
# Validates that required external tools are available.
# Returns: 0 if all dependencies present, 3 if missing.
#===============================================================================

check_dependencies() {
    local -a required_tools=("grep" "find" "wc" "basename" "dirname")
    local missing=0

    for tool in "${required_tools[@]}"; do
        if ! command -v "${tool}" &>/dev/null; then
            log_error "Required tool not found: ${tool}"
            missing=1
        fi
    done

    if [[ "${missing}" -eq 1 ]]; then
        log_error "Install missing dependencies and retry."
        return 3
    fi

    log_verbose "All dependencies verified: ${required_tools[*]}"
    return 0
}

#===============================================================================
# FUNCTION: build_exclude_args
# Constructs grep exclusion arguments from configuration arrays.
# Outputs: Space-separated exclusion arguments for grep.
#===============================================================================

build_exclude_args() {
    local args=""

    for dir in "${EXCLUDE_DIRS[@]}"; do
        args="${args} --exclude-dir=${dir}"
    done

    for ext in "${BINARY_EXTENSIONS[@]}"; do
        args="${args} --exclude=*.${ext}"
    done

    for file in "${EXCLUDE_FILES[@]}"; do
        args="${args} --exclude=${file}"
    done

    printf "%s" "${args}"
}

#===============================================================================
# FUNCTION: should_exclude_file
# Determines if a file path should be excluded from scanning.
# Arguments: $1 - file path to evaluate
# Returns: 0 if should exclude, 1 if should include.
#===============================================================================

should_exclude_file() {
    local filepath="$1"
    local filename
    filename="$(basename "${filepath}")"

    # Check explicit filename exclusions
    for exclude in "${EXCLUDE_FILES[@]}"; do
        if [[ "${filename}" == "${exclude}" ]]; then
            log_verbose "Excluding file (name match): ${filepath}"
            return 0
        fi
    done

    # Check path pattern exclusions
    for path_pattern in "${EXCLUDE_PATH_PATTERNS[@]}"; do
        if [[ "${filepath}" == *"${path_pattern}"* ]]; then
            log_verbose "Excluding file (path match): ${filepath}"
            return 0
        fi
    done

    return 1
}

#===============================================================================
# FUNCTION: scan_text
# Scans a text string for prohibited patterns.
# Arguments: $1 - text to scan, $2 - source identifier
# Returns: 0 if violations found, 1 if clean.
#===============================================================================

scan_text() {
    local text="$1"
    local source="${2:-stdin}"
    local found=1

    for pattern in "${PROHIBITED_PATTERNS[@]}"; do
        if echo "${text}" | grep -iEq "${pattern}"; then
            found=0
            VIOLATIONS_FOUND=1
            local match
            match="$(echo "${text}" | grep -iE "${pattern}" | head -1)"
            VIOLATION_DETAILS+=("Source: ${source} | Pattern: ${pattern} | Match: ${match:0:60}")
        fi
    done

    return "${found}"
}

#===============================================================================
# FUNCTION: scan_commit_message
# Validates a commit message against Protocol Zero.
# Arguments: $1 - commit message text
# Returns: 0 if clean, 1 if violation found.
#===============================================================================

scan_commit_message() {
    local message="$1"

    print_header "Protocol Zero: Commit Message Validation"

    if [[ "${DRY_RUN}" -eq 1 ]]; then
        log_info "DRY RUN: Would scan commit message (${#message} characters)"
        return 0
    fi

    if scan_text "${message}" "commit-message"; then
        log_fail "Protocol Zero Violation Detected in Commit Message"
        printf "\n${RED}${BOLD}Violations:${NC}\n"
        for detail in "${VIOLATION_DETAILS[@]}"; do
            printf "  ${RED}├─${NC} %s\n" "${detail}"
        done
        printf "\n${YELLOW}${BOLD}Action Required:${NC} Remove attribution markers before proceeding.\n\n"
        return 1
    else
        log_pass "Commit message is compliant with Protocol Zero"
        return 0
    fi
}

#===============================================================================
# FUNCTION: scan_codebase
# Performs full codebase scan for Protocol Zero violations.
# Arguments: $1 - root directory to scan (default: current directory)
# Returns: 0 if clean, 1 if violations found.
#===============================================================================

scan_codebase() {
    local root_dir="${1:-.}"

    # Validate directory exists
    if [[ ! -d "${root_dir}" ]]; then
        log_error "Directory not found: ${root_dir}"
        return 2
    fi

    # Resolve to absolute path
    root_dir="$(cd "${root_dir}" && pwd)"

    print_header "Protocol Zero: Codebase Attribution Scan"

    log_info "Scanning directory: ${root_dir}"
    log_info "Excluded directories: ${EXCLUDE_DIRS[*]}"
    log_info "Excluded files: ${EXCLUDE_FILES[*]}"
    log_info "Patterns checked: ${#PROHIBITED_PATTERNS[@]}"
    printf "\n"

    if [[ "${DRY_RUN}" -eq 1 ]]; then
        log_info "DRY RUN: Would scan ${root_dir}"
        log_info "DRY RUN: Exclusions configured, no actual scan performed"
        return 0
    fi

    local exclude_args
    exclude_args="$(build_exclude_args)"

    local -a violations_in_files=()

    for pattern in "${PROHIBITED_PATTERNS[@]}"; do
        log_verbose "Scanning for pattern: ${pattern}"

        # Execute grep with exclusions
        local grep_cmd="grep -rilE ${exclude_args} \"${pattern}\" \"${root_dir}\" 2>/dev/null || true"
        local matches
        matches="$(eval "${grep_cmd}")"

        if [[ -n "${matches}" ]]; then
            while IFS= read -r filepath; do
                # Secondary exclusion check (defense in depth)
                if should_exclude_file "${filepath}"; then
                    continue
                fi

                # Extract line numbers and content
                local line_matches
                line_matches="$(grep -inE "${pattern}" "${filepath}" 2>/dev/null || true)"

                if [[ -n "${line_matches}" ]]; then
                    VIOLATIONS_FOUND=1
                    while IFS= read -r line_match; do
                        local line_num
                        line_num="$(echo "${line_match}" | cut -d: -f1)"
                        local content
                        content="$(echo "${line_match}" | cut -d: -f2-)"
                        violations_in_files+=("${filepath}:${line_num}|${pattern}|${content}")
                    done <<< "${line_matches}"
                fi
            done <<< "${matches}"
        fi
    done

    # Calculate files scanned (approximate, for reporting)
    local files_scanned
    files_scanned="$(find "${root_dir}" -type f \
        ! -path "*/.git/*" \
        ! -path "*/target/*" \
        ! -path "*/dbt_packages/*" \
        ! -path "*/__pycache__/*" \
        ! -path "*/.venv/*" \
        ! -path "*/node_modules/*" \
        ! -path "*/data/*" \
        ! -name "*.pyc" \
        ! -name "*.lock" \
        ! -name "*.png" \
        ! -name "*.jpg" \
        ! -name "*.pdf" \
        2>/dev/null | wc -l | tr -d ' ')"

    log_info "Files scanned: ~${files_scanned}"
    printf "\n"

    if [[ "${VIOLATIONS_FOUND}" -eq 1 ]]; then
        log_fail "Protocol Zero Violation Detected"
        printf "\n${RED}${BOLD}Violations Found:${NC}\n"

        local prev_file=""
        for violation in "${violations_in_files[@]}"; do
            local filepath
            filepath="$(echo "${violation}" | cut -d'|' -f1)"
            local file_part
            file_part="$(echo "${filepath}" | cut -d: -f1)"
            local line_num
            line_num="$(echo "${filepath}" | cut -d: -f2)"
            local pattern
            pattern="$(echo "${violation}" | cut -d'|' -f2)"
            local content
            content="$(echo "${violation}" | cut -d'|' -f3-)"

            if [[ "${file_part}" != "${prev_file}" ]]; then
                printf "\n"
                prev_file="${file_part}"
            fi
            print_violation "${file_part}" "${line_num}" "${content}" "${pattern}"
        done

        printf "\n${YELLOW}${BOLD}Action Required:${NC} Remove attribution markers before proceeding.\n"
        printf "${DIM}Reference: CLAUDE.md Section 1 — Protocol Zero${NC}\n\n"
        return 1
    else
        log_pass "No attribution artifacts detected"
        printf "${DIM}Scanned ${files_scanned} files against ${#PROHIBITED_PATTERNS[@]} patterns${NC}\n\n"
        return 0
    fi
}

#===============================================================================
# FUNCTION: print_usage
# Outputs help documentation.
#===============================================================================

print_usage() {
    cat << EOF
${BOLD}Protocol Zero Enforcement Scanner${NC}
Version: ${SCRIPT_VERSION}

${BOLD}DESCRIPTION${NC}
    Scans codebase and commit metadata for forbidden AI attribution markers
    as defined in CLAUDE.md governance (Section 1 - Protocol Zero).

${BOLD}USAGE${NC}
    ${SCRIPT_NAME} [OPTIONS]

${BOLD}OPTIONS${NC}
    --help, -h              Display this help message
    --version, -v           Display version information
    --dir <path>            Scan specific directory (default: current directory)
    --commit-msg <message>  Validate a commit message string
    --commit-msg-file <path> Validate commit message from file (pre-commit hook)
    --dry-run               Preview scan configuration without executing
    --verbose               Enable extended diagnostic output
    --no-color              Disable colored output

${BOLD}EXIT CODES${NC}
    0   Clean — no violations detected
    1   Violation — attribution markers found
    2   Usage error — invalid arguments or missing files
    3   Environment error — required tools unavailable

${BOLD}EXAMPLES${NC}
    # Scan entire repository
    ${SCRIPT_NAME}

    # Scan specific directory
    ${SCRIPT_NAME} --dir ./models

    # Validate commit message (CI usage)
    ${SCRIPT_NAME} --commit-msg "feat(marts): add fct_daily_mobility"

    # Pre-commit hook integration
    ${SCRIPT_NAME} --commit-msg-file .git/COMMIT_EDITMSG

    # Preview what would be scanned
    ${SCRIPT_NAME} --dry-run --verbose

${BOLD}INTEGRATION${NC}
    Pre-commit hook (.git/hooks/commit-msg):
        #!/bin/sh
        ./tools/protocol-zero.sh --commit-msg-file "\$1"

    GitHub Actions:
        - name: Protocol Zero Check
          run: ./tools/protocol-zero.sh --dir .

${BOLD}GOVERNANCE${NC}
    This script enforces CLAUDE.md Section 1: Protocol Zero.
    Modifications require architectural review per CLAUDE.md Section 2.

EOF
}

#===============================================================================
# FUNCTION: print_version
# Outputs version information.
#===============================================================================

print_version() {
    printf "%s version %s\n" "${SCRIPT_NAME}" "${SCRIPT_VERSION}"
}

#===============================================================================
# FUNCTION: main
# Entry point. Parses arguments and dispatches to appropriate handler.
#===============================================================================

main() {
    local mode="codebase"
    local commit_msg=""
    local commit_msg_file=""
    local scan_dir="."

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --commit-msg)
                if [[ -z "${2:-}" ]]; then
                    log_error "Missing argument for --commit-msg"
                    return 2
                fi
                mode="commit"
                commit_msg="$2"
                shift 2
                ;;
            --commit-msg-file)
                if [[ -z "${2:-}" ]]; then
                    log_error "Missing argument for --commit-msg-file"
                    return 2
                fi
                mode="commit-file"
                commit_msg_file="$2"
                shift 2
                ;;
            --dir)
                if [[ -z "${2:-}" ]]; then
                    log_error "Missing argument for --dir"
                    return 2
                fi
                scan_dir="$2"
                shift 2
                ;;
            --dry-run)
                DRY_RUN=1
                shift
                ;;
            --verbose)
                VERBOSE=1
                shift
                ;;
            --no-color)
                # Colors already disabled via NO_COLOR check at initialization
                shift
                ;;
            --help|-h)
                print_usage
                return 0
                ;;
            --version|-v)
                print_version
                return 0
                ;;
            -*)
                log_warning "Unknown option: $1"
                shift
                ;;
            *)
                log_warning "Unexpected argument: $1"
                shift
                ;;
        esac
    done

    # Validate environment
    check_dependencies || return $?

    log_verbose "Mode: ${mode}"
    log_verbose "Dry run: ${DRY_RUN}"
    log_verbose "Project root: ${PROJECT_ROOT}"

    # Dispatch to handler
    case "${mode}" in
        commit)
            scan_commit_message "${commit_msg}"
            ;;
        commit-file)
            if [[ ! -f "${commit_msg_file}" ]]; then
                log_error "Commit message file not found: ${commit_msg_file}"
                return 2
            fi
            local msg
            msg="$(cat "${commit_msg_file}")"
            scan_commit_message "${msg}"
            ;;
        codebase)
            scan_codebase "${scan_dir}"
            ;;
        *)
            log_error "Unknown mode: ${mode}"
            return 2
            ;;
    esac
}

#===============================================================================
# EXECUTION
#===============================================================================

main "$@"
